# 11장-원시 값과 객체의 비교
### 원시 타입/객체 타입 차이점
> * 원시 타입  
>    * 변경 불가능한 값  
>    * 변수에 할당하면 실제 값 저장  
>    * 다른 변수에 할당하면 원시 값 복사되어 전달  
>    * ==> 값에 의한 전달(pass by value)
>* 객체 타입  
>    * 변경 가능한 값  
>    * 변수에 할당하면 참조 값 저장  
>    * 다른 변수에 할당하면 참조 값 복사되어 전달  
>    * ==> 참조에 의한 전달(pass by reference)

## 11.1 원시 값
> * 변경 불가능한 값  
> * 읽기 전용 값  
> * 데이터의 신뢰성 보장

* 변수 - 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 식별하기 위해 붙인 이름 => 재할당 통해서 변수 값 변경 가능.  
    * 변수 값 재할당 시 원시 값 변경 X, 새로운 메모리 공간 확보 + 재할당한 원시 값 저장 후 재할당한 원시 값 가리킴.
    * 불변성을 갖는 원시 값 할당한 변수 -> `재할당` 밖에 방법이 없음..!
* 값 - 변수에 저장된 데이터, 표현식이 평가되어 생성된 결과 **(변경 불가능하다는 말의 주체)**  
* 상수 - 재할당이 금지된 `변수`

* 문자열 - 문자가 몇 개인지에 따라 필요한 메모리 공간의 크기가 결정

### 문자열 처리 차이(c/java/js)  
> * c - 문자의 배열로 처리  
> * java - string 객체로 처리  
> * js - 원시 타입 제공 **(변경 불가능)**

* 유사 배열 객체 - 배열처럼 인덱스로 프로퍼티 값에 접근 O, length 프로퍼티를 갖는 객체 => ex) 문자열
```javascript
var str = 'string';
str[0] = 'S';
//문자열은 유사 배열 객체라 배열과 유사하게 인덱스로 각 문자에 접근 가능 but 문자열은 원시 값이라 변경 불가능(에러 발생은 X)
console.log(str); //string
```

### 값에 의한 전달 ?
* 변수에는 값이 전달 X, 메모리 주소가 전달 (메모리 주소를 기억)
* 전달된 메모리 주소를 통해 메모리 공간에 접근하면 값 참조 가능!
```javascript
var score = 80;
var copy = score;
console.log(score, copy); // 80 80
console.log(score === copy); // true

// score 변수와 copy 변수는 숫자 값 80을 가짐에 동일함.
// but, 두 값은 다른 메모리 공간에 저장된 별개의 값임.
```
```javascript
var x = 10;
var copy = score;
// score는 식별자 표현식으로 숫자 값 80으로 평가
```
### -> 두 가지 평가 방식 가능  
1. 새로운 80 생성(복사) 후 메모리 주소를 전달 -> 할당 시점에 두 변수가 기억하는 메모리 주소가 다름  
2. score 변수값 80의 메모리 주소를 그대로 전달 -> 할당 시점에 두 변수가 기억하는 메모리 주소가 같음

* 두 변수의 원시 값은 서로 다른 메모리 공간에 저장된 별개의 값   
     * 재할당을 통해 값 변경해도 간섭이 불가능!

## 11.2 객체
* 메모리 공간의 크기를 사전에 정해 둘 수 없음.
### 객체 관리 방식 차이
> * java/c++(클래스 기반 언어)  
>   * 사전에 정의된 클래스 기반으로 객체 생성  
>   * 객체 생성 이전에 프로퍼티, 메서드 정해져 있음
>   * 객체 생성 이후 동적으로 프로퍼티 추가/삭제 불가
> * javascript
>   * 클래스 없이 객체 생성 가능
>   * 동적으로 프로퍼티, 메서드 추가 가능
>   * 생성과 프로퍼티 접근에 비용이 더 많이드는 방식..

### 참조값
> * 생성된 객체가 저장된 메모리 공간의 주소
> * 실제 객체가 접근 가능
```javascript
var person = {
    name: 'Lee'
};
// person 변수에 저장되어 있는 참조 값으로 실제 객체에 접근
console.log(person); // {name: "Lee"}
```
### 객체 부작용
* 객체 복사 생성 비용 절약, 성능 향상 위해 변경 가능한 값으로 설계했지만, **여러 개의 식별자가 하나의 객체를 공유**할 수 있음..!

### 객체 복사
> * 얕은 복사
>   * 한 단계까지만 복사
>   * 원시 값을 할당한 변수를 다른 변수에 할당
> * 깊은 복사
>   * 객체에 중첩되어 있는 객체까지 모두 복사
>   * 객체를 할당한 변수를 다른 변수에 할당
```javascript
var person = {
    name: 'Lee'
};

var copy = person; // 참조 값을 복사(얕은 복사)
```
* 객체를 가리키는 변수(원본, person)를 다른 변수(사본, copy)에 할당하면 원본의 참조 값이 복사되어 전달 => 참조에 의한 전달  
* 메모리 주소가 다르지만 동일한 참조 값을 가짐  
    * 두 개의 식별자가 하나의 객체를 공유
    * 어느 한쪽에서 객체 변경 시 서로 영향을 주고 받음
```javascript
var person1 = {
    name: 'Lee'
};

var person2 = {
    name: 'Lee'
};

console.log(person1 === person2);
// 두 변수가 가리키는 객체 내용은 같지만 다른 메모리에 저장된 별개의 객체(두 변수의 참조 값은 전혀 다른 값)이므로 false
console.log(person1.name === person2.name);
// 두 표현식 모두 원시 값 'Lee'로 평가되기 때문에 true
```