# 25장-클래스
## 25.1 클래스는 프로토타입의 문법적 설탕인가?
- No! 새로운 객체 생성 메커니즘!
- js는 프로토타입 기반 객체지향 언어
    - 프토토타입 기반 객체지향 언어 = 클래스가 필요없는 객체지향 프로그래밍 언어
### 클래스 VS 생성자 함수
> ### 클래스
>   - new 연산자 없이 호출 -> 에러 발생
>   - **상속 지원하는 extends, super 키워드 제공**
>   - 호이스팅 발생 안하는 것처럼 동작
>   - 모든 코드에 암묵적으로 strict mode 지정되어 실행, strict mode 해제 불가
>   - constructor, 프로토타입 메서드, 정적 메서드는 모두 프로퍼티 어트리뷰트 [[Enumerable]]의 값이 false (= 열거되지 않음)

> ### 생성자 함수
>   - extends와 super 키워드 지원 X
>   - 함수 선언문으로 정의된건 함수 호이스팅, 함수 표현식으로 정의된건 변수 호이스팅 발생
>   - 암묵적으로 strict mode 지정 X

## 25.2 클래스 정의
- class 키워드 사용
- 이름은 파스칼 케이스 사용이 일반적 (사용안해도 에러는 아님)
```javascript
class 이름 {} // 클래스 선언문
```
- 이름 가질 수도 안가질 수도 있음

### 일급 객체로서의 클래스 특징
- 무명 리터럴로 생성 O (=런타임에 생성 가능)
- 변수, 자료구조에 저장 O
- 함수의 매개변수에 전달 O
- 함수의 반환값으로 사용 O
- 몸체에는 0개 이상의 메서드 정의 가능
    - 정의할 수 있는 메서드 = constructor(생성자), 프로토타입 메서드, 정적 메서드

## 25.3 클래스 호이스팅
- 클래스는 함수로 평가
- 클래스 선언문으로 정의한 클래스 -> 런타임 이전에 먼저 평가, 함수 객체 생성
    - 함수 객체 생성 시 프로토타입도 더불어 생성
    - 클래스가 평가되어 생성된 함수 객체 = 생성자 함수로서 호출할 수 있는 함수 (=constructor)
- 클래스 정의 이전에 참조 불가능

## 25.4 인스턴스 생성
- 클래스 = 생성자 함수, new 연산자와 함께 호출되어 인스턴스 생성
    - 클래스의 유일한 존재 이유 = 인스턴스 생성 => 반드시 new와 함께 호출

## 25.5 메서드
### constructor
- 인스턴스 생성, 초기화 위한 특수한 메서드
- 이름 변경 불가능
- 클래스 몸체에 정의한 constructor은 메서드로 해석 X, 클래스가 평가되어 생성한 함수 객체 코드의 일부가 됨
    - 클래스 정의가 평가되면 constructor의 기술된 동작을 하는 함수 객체가 생성
- 클래스 내에 최대 한 개만 존재 가능(2개 이상이면 문법 에러 발생)
- 생략 가능 -> 빈 constructor가 암묵적으로 정의 => 생략한 클래스는 빈 constructor에 의해 빈 객체 생성
- 프로퍼티가 추가되어 초기화된 인스턴스 생성 -> constructor 내부에서 this에 인스턴스 프로퍼티 추가
- 인스턴스 생성 시 클래스 외부에서 인스턴스 프로퍼티 초기값 전달
    - constructor이 매개변수 선언, 인스턴스 생성 시 초기값 전달(초기값은 constructor의 매개변수에게 전달)
- 인스턴스의 생성과 동시에 인스턴스 프로퍼티 추가를 통해 인스턴스 초기화 실행
    - 인스턴스 초기화하려면 constructor 생략 X
- 별도의 반환문을 갖지 않아야 함(return문 반드시 생략)

### 프로토타입 메서드
- 클래스의 prototype 프로퍼티에 메서드 추가 안해도 기본적으로 프로토타입 메서드 됨
- 클래스가 생성한 인스턴스는 프로토타입 체인의 일원이 됨
- 클래스 = 생성자 함수와 같이 인스턴스를 생성하는 생성자 함수
    - = 프로토타입 기반의 객체 생성 메커니즘

### 정적 메서드 VS 프로토타입 메서드
- 자신이 속해 있는 프로토타입 체인이 서로 다름
- 정적 메서드
    - 클래스로 호출, 인스턴스 프로퍼티 참조 X
- 프로토타입 메서드
    - 인스턴스로 호출, 인스턴스 프로퍼티 참조 O

### 클래스에서 정리한 메서드의 특징
1. function 키워드 생략한 메서드 축약 표현 사용
2. 클래스에 메서드 정의할 때 콤마 필요 X
3. 암묵적 strict mode로 실행
4. for...in 이나 Object.keys 메서드 등으로 열거 X, [[Enumerable]]의 값이 false
5. 내부 메서드 [[Constructor]]을 갖지 X -> new 연산자와 함께 호출 X

## 25.6 클래스의 인스턴스 생성 과정
1. 인스턴스 생성과 this 바인딩
    - new 연산자와 함께 클래스 호출 -> constructor 내부 코드 실행 앞서 암묵적으로 빈 객체(=클래스가 생성한 인스턴스) 생성
    - 클래스가 생성한 인스턴스의 프로토타입으로 클래스의 prototype 프로퍼티가 가리키는 객체가 설정
    - 암묵적 생성된 빈 객체(=인스턴스)는 this에 바인딩
        - constructor 내부의 this는 클래스가 생성한 인스턴스를 가리킴
2. 인스턴스 초기화
    - constructor 내부 코드 실행 -> this에 바인딩되어 있는 인스턴스 초기화
        - this에 바인딩되어 있는 인스턴스에 프로퍼티 추가, constructor가 인수로 전달받은 초기값으로 인스턴스의 프로퍼티 값 초기화
        - constructor이 생략되면 이 과정도 생략됨
3. 인스턴스 반환
    - 모든 처리가 끝나면 완성된 인스턴스가 바인딩된 this가 암묵적으로 반환

## 25.7 프로퍼티
### 인스턴스 프로퍼티
- constructor 내부에서 정의
- constructor 내부에서 this에 인스턴스 프로퍼티 추가 -> 인스턴스 초기화
    - = 클래스가 생성한 인스턴스의 프로퍼티
- 언제나 `public`

### 접근자 프로퍼티
- 자체적으로는 값([[Value]])을 갖지 X, 다른 데이터 프로퍼티의 값을 읽거나, 저장할 때 사용하는 `접근자 함수`로 구성된 프로퍼티
- getter는 get 키워드 사용 정의, 인스턴스 프로퍼티 접근할 때마다 프로퍼티 값 조작, 별도의 행위 필요 시 사용
- setter는 set 키워드 사용 정의, 인스턴스 프로퍼티 접근할 때마다 프로퍼티 값 조작, 별도의 행위 필요 시 사용
- getter/setter의 이름은 인스턴스 프로퍼티처럼 사용
- getter 호출 X, 프로퍼티처럼 참조하는 형식으로 사용, 참조 시 내부적으로 getter 호출
- setter도 호출 X, 프로퍼티처럼 값을 할당하는 형식으로 사용, 참조 시 내부적으로 setter 호출
- getter = 반드시 무언가를 반환
- setter = 반드시 매개변수가 있어야 함(단 하나의 값만 할당 받음 -> 단 하나의 매개변수만 선언)
- Not 인스턴스 프로퍼티, Yes 프로토타입 프로퍼티

### 클래스 필드 정의 제안
- 클래스 필드 = 클래스 기반 객체지향 언어에서 클래스가 생성할 인스턴스의 프로퍼티를 가리키는 용어
- js의 클래스 몸체에는 메서드만 선언 가능
- 클래스 몸체에서 클래스 필드 정의하는 경우 this에 클래스 필드를 바인딩해서는 X
- 클래스 필드 참조 시 js에서는 this 반드시 사용
- 초기값 할당 X -> undefined
- 인스턴스 생성 시 외부의 초기값으로 클래스 필드 초기화 -> constructor에서 클래스 필드 초기화
- 메서드 정의도 가능
- 인스턴스 프로퍼티 정의 방식
    - 외부 초기값으로 클래스 필드 초기화 O -> constructor에서 인스턴스 프로퍼티 정의
    - 외부 초기값으로 클래스 필드 초기화 X -> constructor에서 인스턴스 프로퍼티 정의, 클래스 필드 정의 모두 사용 가능

### private 필드 정의 제안
- 필드의 선두에 `#`을 붙여줌
- 필드 참조할 때도 `#` 붙여야함  
<table style="undefined;table-layout: fixed; width: 502px">
<colgroup>
<col style="width: 200px">
<col style="width: 151px">
<col style="width: 151px">
</colgroup>
<thead>
  <tr>
    <th>접근 가능성</th>
    <th>public</th>
    <th>private</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td>클래스 내부</td>
    <td>O</td>
    <td>O</td>
  </tr>
  <tr>
    <td>자식 클래스 내부</td>
    <td>O</td>
    <td>X</td>
  </tr>
  <tr>
    <td>클래스 인스턴스를 통한 접근</td>
    <td>O</td>
    <td>X</td>
  </tr>
</tbody>
</table>

- 클래스 외부에서 직접 접근 방법 X
- 접근자 프로퍼티 통해 간접 접근 O
- 반드시 클래스 몸체에 정의
- 직접 constructor에 정의 -> 에러 발생

### static 필드 정의 제안
- 정적 메서드는 정의 O, 정적 필드는 정의 X -> but 현시점에선 가능해짐

## 25.8 상속에 의한 클래스 확장
- 기존 클래스를 상속받아 새로운 클래스를 확장하여 정의
- extends 키워드 기본 제공
- 상속을 통해 확장된 클래스 = 서브클래스 (=파생 클래스, 자식 클래스)
- 서브 클래스에게 상속된 클래스 = 수퍼클래스 (=베이스 클래스, 부모 클래스)
- extends 키워드 역할 : 수퍼클래스와 서브클래스 간의 `상속 관계 설정`(프로토타입 통해서)
- 수퍼클래스 + 서브클래스는 인스턴스의 프로토타입 체인 + 클래스 간의 프로토타입 체인 생성
    - 프로토타입 메서드, 정적 메서드 모두 상속 가능

### 동적 상속
- 생성자 함수를 상속받아 클래스 확장도 가능
    - 단, extends 키워드 앞에 반드시 클래스 필수
- extends 키워드 다음에는 클래스, [[Constructor]] 내부 메서드를 갖는 함수 객체로 평가될 수 있는 모든 표현식 사용가능 -> 동적으로 상속받을 대상 결정 가능
### 서브클래스의 constructor
```javascript
constructor(){}
// 서브클래스에서 constructor 생략 시 암묵적 constructor 정의
```
```javascript
constructor(...args){super(...args);}
// super()는 수퍼클래스의 constructor 호출 -> 인스턴스 생성
// args는 new 연산자와 함께 클래스 호출 시 전달한 인수의 리스트
```
- 프로퍼티 소유하는 인스턴스 생성하려면 constructor 내부에서 인스턴스 프로퍼티 추가

### Rest 파라미터
- 매개변수에 ...을 붙임
- 함수에 전달된 인수들의 목록을 배열로 전달받음
```javascript
class Base{}
// 수퍼클래스
class Derived extends Base{}
// 서브클래스
// 둘 다 constructor 생략 -> 빈 객체 생성
```

### super 키워드
- 함수처럼 호출 O, this 같은 식별자처럼 참조 O인 특수한 키워드
- super 호출 -> 수퍼클래스 `constructor` 호출
- super 참조 -> 수퍼클래스 `메서드` 호출
- 수퍼클래스에서 추가한 프로퍼티 + 서브클래스에서 추가한 프로퍼티를 갖는 인스턴스 생성
    - 서브클래스의 constructor 생략 불가
    ### super 호출 시 주의사항
    1. 서브클래스 constructor 생략 X -> 서브클래스의 constructor에는 반드시 super 호출
    2. 서브클래스 constructor에서 super 호출 전까지는 this 참조 불가
    3. super는 반드시 서브클래스의 constructor에서만 호출(아니면 에러 발생)
- super 참조는 수퍼클래스의 메서드를 참조하기 위해 사용 -> 서브클래스의 메서드에서 사용해야 함

### 상속 클래스의 인스턴스 생성 과정
1. 서브클래스의 super 호출
    - 상속받지 않는 클래스(&생성자 함수)는 내부 슬롯 [[ConstructorKind]]의 값이 `base`로 설정
    - 상속받는 서브클래스는 내부 슬롯 [[ConstructorKind]]의 값이 `derived`로 설정
        - **직접 인스턴스 생성 X, 수퍼클래스에게 인스턴스 생성 위임**
        - => 서브클래스 constructor에서 반드시 super 호출해야하는 이유
2. 수퍼클래스의 인스턴스 생성과 this 바인딩
    - 수퍼클래스의 constructor 내부의 this는 생성된 인스턴스를 가리킴
    - 인스턴스는 수퍼클래스가 생성함
    - new 연산자와 함께 호출한 클래스 -> 서브클래스
3. 수퍼클래스의 인스턴스 초기화
- 수퍼클래스의 constructor가 실행되어 this에 바인딩되어 있는 인스턴스 초기화
- this에 바인딩되어 있는 인스턴스에 프로퍼티 추가, constructor가 인수로 전달받은 초기값으로 인스턴스 프로퍼티 초기화
4. 서브클래스 constructor로의 복귀와 this 바인딩
- super 호출 종료, 제어 흐름이 서브클래스의 constructor로 돌아옴
    - super가 반환한 인스턴스가 this에 바인딩
    - 서브클래스는 별도의 인스턴스 생성 X, super이 반환한 인스턴스를 this에 바인딩하여 그대로 사용
- **super 호출 X -> 인스턴스 생성 X, this 바인딩 X**
    - => 서브클래스의 constructor가 super 호출 전에 this 참조할 수 없는 이유
5. 서브클래스의 인스턴스 초기화
- super 호출 이후, 서브클래스의 constructor에 기술되어 있는 인스턴스 초기화 실행
- this에 바인딩되어 있는 인스턴스에 프로퍼티 추가, constructor가 인수로 전달받은 초기값으로 인스턴스의 프로퍼티 초기화
6. 인스턴스 반환
- 클래스 모든 처리 끝 -> 완성된 인스턴스가 바인딩된 this 암묵적 반환