# 38장-브라우저의 렌더링 과정
### 파싱
> 텍스트 문서를 읽어 들여 실행하기 위해 텍스트 문자열을 토큰으로 분해(어휘 분석), 토큰에 문법적 의미와 구조를 반영 -> 파스트리를 생성하는 일련의 과정

### 렌더링
> HTML, CSS, 자바스크립트로 작성된 문서를 파싱 -> 브라우저에 시각적으로 출력

### 브라우저 렌더링 과정
1. 브라우저는 HTML, CSS, 자바스크립트, 이미지, 폰트 파일 등 렌더링에 필요한 리소스 요청, 서버로부터 응답받음
2. 브랑루저의 렌더링 엔진은 서버로부터 응답된 HTML, CSS를 파싱 -> DOM과 CSSOM을 생성, 결합 -> 렌더 트리 생성
3. 브라우저의 자바스크립트 엔진은 서버로부터 응답된 자바스크립트 파싱 - AST 생성, 바이트 코드로 변환 후 실행
    - 자바스크립트는 DOM API를 통해 DOM, CSSOM을 변경할 수 있음 -> 변경된 DOM과 CSSOM은 다시 렌더 트리로 결합
4. 렌더 트리 기반으로 HTML 요소의 레이아웃 계산, 브라우저 화면에 HTML 요소 페인팅

## 38.1 요청과 응답
- 브라우저의 핵심 기능 : 필요한 리소스를 서버에 요청, 서버로부터 응답 받아(리소스 파싱 후) 브라우저에 시각적으로 렌더링
    - 렌더링에 필요한 리소스는 모두 서버에 존재
- 서버에 요청 전송 위해 브라우저는 주소창 제공
    - 브라우저에 URL 입력 -> URL의 호스트 이름이 DNS를 통해 IP 주소로 변환 -> 해당 IP 주소를 갖는 서버에게 요청 전송
- 일반적으로 서버는 루트 요청에 대해 암묵적으로 index.html을 응답하도록 기본 설정
- 정적 파일 말고도 자바스크립트를 통해 정적/동적 데이터 요청 가능
- 요청과 응답은 개발자 도구의 Network 패널에서 확인 가능

## 38.2 HTTP 1.1과 HTTP 2.0
- HTTP : 웹에서 브라우저와 서버가 통신하기 위한 프로토콜
- HTTP 1.1
    - 커넥션 당 하나의 요청과 응답만 처리(여러 개의 요청을 한 번에 전송, 응답 x)
    - 각 태그에 의한 리소스 요청이 개별적 전송, 응답
    - 요청할 리소스 개수에 비례하여 응답 시간도 증가하는 `단점`

- HTTP 2.0
    - 커넥션 당 여러 개(다중)의 요청과 응답 가능
    - HTTP 1.1에 비해 페이지 로드 속도가 약 50%정도 빠름

## 38.3 HTML 파싱과 DOM 생성
1. 서버에 존재하던 HTML 파일이 브라우저의 요청에 의해 응답
    - 서버는 브라우저가 요청한 HTML 파일을 읽어 들여 메모리에 저장
        - 메모리에 저장된 바이트를 인터넷을 경유하여 응답

2. 브라우저는 서버가 응답한 HTML 문서를 바이트 형태로 응답 받음
    - 응답된 바이트 형태의 HTML 문서는 meta 태그의 charset 어트리뷰트에 의해 지정된 인코딩 방식을 기준으로 문자열로 변환
        - content-type:text/html; charset=utf-8 응답 헤더에 담겨 응답

3. 문자열로 변환된 HTML 문서를 읽어 들여 문법적 의미를 갖는 코드의 최소 단위인 `토큰`들로 분해

4. 각 토큰들을 객체로 변환 -> `노드`들을 생성
    - ex) 문서 노드, 요소 노드, 어트리뷰트 노드, 텍스트 노드
    - 노드는 이후 DOM을 구성하는 기본 요소가 됨
    - **DOM = HTML 문서로 파싱한 결과물**

5. HTML 문서는 HTML 요소들의 집합으로 이루어짐
    - **HTML 요소는 중첩 관계를 가짐**
    - HTML 요소의 콘텐츠 영역에는 텍스트뿐만 아니라 다른 HTML 요소도 포함 가능
    - 중첩 관계에 의해 `부자 관계` 형성
    - HTML 요소 간의 부자 관계를 바나영하여 모든 노드들을 `트리 자료구조`로 구성 -> DOM이라 부름

## 38.4 CSS파싱과 CSSOM 생성
- 렌더링 엔진이 HTML을 처음부터 한 줄씩 순차적으로 파싱 -> DOM을 생성해 나감
- DOM을 생성해 나가다가 CSS를 로드하는 link 태그 or style 태그 만나면 DOM 생성 일시 중지
- link 태그의 href 어트리뷰트에 지정된 CSS 파일을 서버에 요청하여 로드한 CSS 파일 or style 태그 내의 CSS를 HTML과 동일한 파싱과정을 거치며 해석 -> CSSOM을 생성
    - 파싱과정 : 바이트 => 문자 => 토큰 => 노드 => CSSOM
- CSSOM은 CSS의 상속을 반영하여 생성됨

## 38.5 렌더 트리 생성
- 렌더링 엔진은 서버로부터 응답된 HTML과 CSS 파싱
    - 각각 DOM과 CSSOM 생성
    - 렌더링 위해 `렌더 트리`로 결합
        - 렌더 트리 : 렌더링을 위한 트리 구조의 자료구조
        - 브라우저 화면에 렌더링되지 않는 노드와 CSS에 의해 비표시되는 노드들은 조합하지 않음(브라우저 화면에 렌더링되는 노드만으로 구성)
- 완성된 렌더 트리는 각 HTML 요소의 레이아웃을 계산하는 데 사용, 브라우저 화면에 픽셀을 렌더링하는 페인팅 처리에 입력됨

### 반복해서 레이아웃 계산과 페인팅이 재차 실행되는 경우
- 비용이 많이 드는, 성능에 악영향 주는 작업이므로 될 수 있으면 x
> - 자바스크립트에 의해 노드 추가/삭제
> - 브라우저 창의 리렌더링에 의한 뷰포트 크기 변경
> - HTML 요소의 레이아웃에 변경을 발생시키는 width/height, margin, padding, border, display, position, top/rigth/bottom/left 등의 스타일 변경

## 38.6 자바스크립트 파싱과 실행
- 자바스크립트 엔진이 처리 (Not 브라우저의 렌더링 엔진)
    - 자바스크립트 엔진 : js코드를 파싱 => CPU가 이해할 수 있는 저수준 언어로 변환, 실행
- js 엔진은 렌더링 엔진으로부터 제어권을 넘겨받으면 js 코드 파싱 시작
    - AST 기반으로 인터프리터가 실행 할 수 있는 중간 코드인 바이트코드 생성 후 실행

### 토크나이징
- 단순 문자열인 js 소스코드를 어휘 분석하여 문법적 의미를 갖는 최소단위인 토큰들로 분해 (렉싱과 유사)

### 파싱
- 토큰들의 집합을 구문 분석하여 AST 생성
    - AST : 토큰에 문법적 의미와 구조를 반영한 트리 구조의 자료구조
- 인터프리터, 컴파일러 + TypeScript, Babel, Prettier 같은 트랜스파일러 구현도 가능

### 바이트코드 생성과 실행
- v8엔진의 경우 터보팬이라 불리는 컴파일러에 의해 최적화딘 머신 코드로 컴파일되어 성능 최적화 (코드 사용 빈도 적어지면 디옵티마이징 하기도 함)

## 38.7 리플로우와 리페인트
- js코드에 DOM or CSSOM 변경하는 DOM API 사용
    - DOM이나 CSSOM이 변경
    - 다시 렌더 트리로 결합 -> 변경된 렌더 트리를 기반으로 레이아웃과 페인트 과정 거쳐 브라우저 화면에 다시 렌더링
- 리플로우 : 레이아웃 계산을 다시 하는 것을 의미
    - 노드 추가/삭제, 요소 크기/위치 변경, 윈도우 리사이징등 `레이아웃에 영항을 주는 변경이 발생한 경우에 한하여 실행`
- 리페인트 : 재결합된 렌더 트리를 기반으로 다시 페인트 함을 의미
- 두 가지가 반드시 순차적으로 동시 실행은 x
- 레이아웃에 영향이 없는 변경의 경우에는 리플로우 없이 리페인팅만 실행

## 38.8 자바스크립트 파싱에 의한 HTML 파싱 중단
- 브라우저는 동기적으로(위에서 아래방향으로, 순차적으로) HTML, CSS, 자바스크립트를 파싱하고 실행
    - **script 태그의 위치에 따라** HTML 파싱이 블로킹되어 DOM 생성 지연될 수 있음을 의미
- js 코드에서 DOM이나 CSSOM을 변경하는 DOM API 사용 경우 DOM이나 CSSOM이 이미 생성되어 있어야 함

## 38.9 script 태그의 async/defer 어트리뷰트
- src 어트리뷰트를 통해 외부 js 파일을 로드하는 경우에만 사용할 수 있음(src 어트리뷰트가 없는 인라인 자바스크립트에는 사용할 수 없음)
- HTML 파싱과 외부 js 파일의 로드가 비동기적으로 동시에 진행

### async 어트리뷰트
- js의 파싱과 실행은 `js 파일의 코드가 완료된 직후`에 진행되며, 이때 `HTML 파싱이 중단`
- 여러 개의 script 태그에 async 어트리뷰트 지정 시 태그의 순서와 상관없이 로드가 완료된 js부터 먼저 실행
    - 순서 보장 X
        - 순서 보장이 필요한 script 태그에는 async 지정하면 안됨

### defer 어트리뷰트
- js의 파싱과 실행은 `HTML 파싱이 완료된 직후`, `DOM 생성이 완료된 직후` 진행됨
- DOM 생성이 완료된 이후 실행되어야 할 js에 유용함