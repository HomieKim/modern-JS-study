# 원시 값과 객체의 비교
- 원시 값은 변경 불가능한 값
- 객체는 변경 가능한 값
- 원시 값을 변수에 할당 하면 실제 값이 저장
- 객체를 변수에 할당하면 참조 값이 저장
> 원시값을 갖는 변수를 다른 변수에 할당 시 **원시 값이 복사되어 전달** 됩니다. 이를 **값에 의한 전달**(`pass by value`)**이라고 합니다.

> 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 **참조값이 복사되어 전달** 됩니다. 이를 **참조에 의한 전달**(`pass by value`) 라고 합니다.

## 원시 값
### 변경 불가능한 값
- 원시 값은 변경 불가능 한 값으로 데이터의 신뢰성을 보장 
- 재할당 시 이전의 원시 값을 변경하는 것이 아니라 변수가 새로운 메모리 공간의 주소를 참조함
- `const`는 변수의 재할당을 막는 것, 원시 값 자체는 변경되는 것 아님
### 문자열과 불변성
- 원시 타입별로 확보해야 하는 메모리 크기가 미리 정해져 있다.
- 문자열 원시값 경우 몇개의 문자로 이루어 졌는냐에 따라 필요한 메모리 공간의 크기가 결정 됨
- 자바스크립트에서는 문자열을 원시 타입으로 제공(`c`는 문자의 배열로 처리 `java`는 String객체로 처리)
- 문자열은 유사 배열 객체 이면서 이터러블 이므로 배열과 유사하게 각 문자에 접근 할 수 있다.
```js
var str = 'string';

// 문자열은 유사 배열이므로 배열과 유사하게 인덱스를 사용해 각 문자에 접근할 수 있다.
console.log(str[0]); // s

// 원시 값인 문자열이 객체처럼 동작한다.
console.log(str.length); // 6
console.log(str.toUpperCase()); // STRING
str[0] ='S' // 생성된 문자열 일부를 변경하는 건 반영되지  않는다 (원시값은 불변성 갖기 때문)
```
### 값에 의한 전달
- 변수에 원시 값을 갖는 변수를 할당하면 변수에 할당된 값이 복사되어 전달 된다
- 복사된 원시 값만 같을 뿐 **다른 메모리 공간에 저장된 별개의 값**으로 존재
- 엄격하게 따지면 변수에는 **메모리 주소** 가 전달됨

## 객체
- 객체는 원시 값처럼 사전에 메모리 공간을 확보 해 둘 수없다. (동적으로 추가도 가능)
- 원시 값과 비교하여 객체의 관리 방식이 복잡
 -   대부분의  `JavaScript Engine`은 해시 테이블과 유사하지만 높은 성능을 위해 일반적인 해시 테이블보다 더 나은 방법으로 객체 구현.
 - 프로퍼티 접근을 위해 히든클래스 라는 방식 사용

### 변경 가능한 값
- 객체는 변경 가능한 값이다.
- 객체를 할당하고 있는 변수의 메모리 공간에 접근하면 **참조값**(`reference value`)에 접근할 수 있다.
- 참조 값은 메모리 공간의 주소 그 자체, 참조 값을 통해 실제 객체에 접근한다.
- 객체를 할당한 변수는 재할당 없이 객체를 직접 변경할 수 있다. 
- 프로퍼티를 동적 추가, 갱신, 삭제 가능한 것도 변경가능한 값이기 때문 
- 객체를 할당한 변수의 참조 값(메모리 주소를 참조했을 때 나오는 참조 값)은 변경되지 x
- 구조적 단점 : 여러 개의 식별자가 하나의 객체를 공유할 수 있다.

### 참조에 의한 전달
- 얉은 복사 vs 깊은 복사
> 얉은 복사와 깊은 복사로 생성된 객체는 모두 원본과 다른 객체

> 하지만 깊은 복사는 객체에 중첩되어있는 객체까지 모두 복사해서 원시 값 처럼 완전한 복사본을 만듬

- 객체를 할당한 변수를 다른 변수에 할당하면 원본의 **참조 값이 복사되어 전달**된다. 이를 **참조에 의한 전달** 이라고 한다.
-  엄격하게 구분하면 메모리 공간에 저장되어 있는 값을 복사해서 전달하므로 **값에 의한 전달**과 동일
- 다만 변수에 저장되어 있는 값이 **참조 값** 이라면 같은 객체를 공유하게 되므로 ** 참조에 의한 전달 ** 이라 표현
