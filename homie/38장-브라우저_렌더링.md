
# 브라우저의 렌더링 과정
- 클라이언트 사이드의 자바스크립트는 브라우저 위에서 동작합니다.
- 브라우저가 HTML, CSS, javascript 로 작성된 텍스트 문서를 어떻게 파싱하여 렌더링하는지 이해하는 것이 중요합니다.

### 파싱(parsing)
- 파싱(구문 분석 `syntax analysis`)은 텍스트 문서를 읽어들여  실행하기 위해 텍스트 문서의 문자열을 토큰(`token`)으로 분해(어휘 분석 `lexical analysis`)하고 토큰의 문법적 의무와 구조를 반영하여 파스 트리(`parse tree`)를 생성하는 일련의 과정을 말합니다.
- 파싱이 완료된 이후에는 파스트리를 기반으로 중간언어인 바이트코드를 생성하고 실행합니다.

### 렌더링(rendering)
- 렌더링 HTML, CSS 자바스크립트로 작성된 문서를 파싱하여 브라우저에 시각적으로 출력하는 것을 말한다.
- 브라우저 렌더링 과정
	1. 브라우저는 HTML, CSS, JS 등 렌더링에 필요한 리소스를 요청하고 서버로 부터 응답을 받는다.
	2. 브라우저의 렌더링엔진은 서버로부터 응답된 HTML과 CSS를 파싱하여 `DOM`과 `CSSOM`을 생성하고 이를 결합하여 **렌더 트리**를 생성
	3. 브라우저의 자바스크립트 엔진은 서버로 부터 응답된 자바스크립트를 파싱하여 AST(`Abstract Syntax Tree`)를 생성하고 바이트코드로 변환하여 실행(이때 자바스크립트는 `DOM API`를 통해 `DOM`이나 `CSSOM`을 변가능)
	4. 렌더 트리를 기반으로 HTML 요소의 레이아웃을 계산하고 브라우저 화면에 HTML요소를 페인팅한다.

## 요청과 응답
- 브라우저의 핵심 기능은 필요한 리소스(HTML, CSS, JS 등등..)를 요청(`request`)하고 응답(`response`)받아 브라우저에 렌더링하는 것이다.
- 렌더링에 필요한 리소스는 모두 서버에 존재하므로 필요한 리소스를 서버에 요청하고 응답 받은 리소스를 파싱하여 렌더링 하는 것
- 브라우저는 서버에 요청을 전송하기 위해 주소창을 제공한다. 
- 주소창에 `URL`을 입력하여 전송 하면 `URL`의 호스트 이름이 `DNS`를 통해 `IP`주소로 변환되고 이 `IP` 주소를 갖는 서버에게 요청을 전송한다.
- 루트 요청은 암묵적으로 `index.html`을 응답
- index.html이 아닌 다른 정적 파일을 요청할 경우 해당 정적 파일을 경로를 `Path`에 기술하여 서버에 요청
> 자바스크립트를 통해 동적으로 데이터를 요청할 수 있는데 이를 'ajax'라고 합니다.
- 서버에 index.html 요청시 CSS, JS, 이미지, 폰트 등 외부 리소스도 같이 응답 됩니다.
> 이는 브라우저 엔진이 HTML을 파싱하는 도중 img, link, script 등의 태그를 만나면 HTML파싱을 잠시 중단하고 외부 리소스 파일을 요청하기 때문

## HTTP 1.1 과 HTTP 2.0

- HTTP(`HyperText Transfer Protocol`)는 웹에서 브라우저와 서버가 통기하기 위한 프로토콜 입니다.
- HTTP/1.1은 기본적으로 커넥션당 하나의 요청과 응답만 처리합니다.
- HTTP/2.0은 커넥션당 여러개의 요청과 응답, 즉 다중 요청/응답이 가능합니다.
- 여러 리소스의 동시 전송이 가능하므로 HTTP/1.1에 비해 로드 속도가 더 빠릅니다.

## HTML 파싱과 DOM 생성
- HTML 문서는 문자열로 이루어진 순서한 텍스트입니다.
- HTML 문서를 브라우저에 시각적인 픽셀로 렌더링 하려면, 브라우저가 이해할 수 있는 자료 구조(객체)로 변환하여 메모리에 저장해야 합니다.
- 즉, 브라우저 엔진은 HTML문서를 파싱하여 브라우저가 이해할 수 있는 자료구조인 DOM(`Document Object Model`)을 생성합니다.

### DOM 생성 과정
1. 서버에 존재하던 `HTML` 파일이 브라우저 요청에 의해 응답 된다.
2. 서버는 요청된 `HTML`  파일을 읽어들여 메모리에 저장한 다음 메모리에 저장된 바이트(2진수)를 경유하여 응답
3. 브라우저는 서버가 응답한 `HTML` 문서를 바이트(2진수)형태로 응답받음
4. 응답된 `HTML` 문서는 `meta` 태그의 `charset` 어티리뷰트에 의해 지정된 인코딩 방식을 기준으로 문자열변환
(이때 `meta` 태그의 어트리뷰트는 응답 헤더(`response header`)에 담겨 응답됩니다.) 
5. 문자열로 변환된 `HTML` 문서를 읽어 들여 문법적 의미를 갖는 코드의 최소 단위인 토큰(`token`)들로 분해
6. 각 토큰들을 객체로 변환하여 노드(`node`)를 생성 (토큰의 내용에 따라 문서 노드, 요소 노드 등으로 분류)
7. `HTML` 문서는 `HTML` 요소들의 집합으로 이루어지며 **HTML 요소는 중첩관계**를 갖는다. 즉, 중첩 관계에 의해 형성된 노드들을 트리 구조로 구성, 노드들로 이루어진 트리 자료구조를 `DOM이라고` 한다.

## CSS 파싱과 CSSOM 생성
- 렌더링 엔진은 `DOM`을 생성하다 CSS를 로드하는 `link` 태그나 `style`태그를 만나면 DOM 생성을 일시 중단합니다.
- `CSS` 파일이나 `style` 태그 내의 `CSS`를 `HTML`과 동일한 과정으로 파싱하여 CSSOM(`CSS Object Model`) 생성
- `CSSOM`이 생성 완료되면 일시 중단되 DOM 트리 생성을 재개
- `CSSOM`은 상속관계를 반영

## 렌더 트리 생성
- `DOM` 과 `CSSOM`은 렌더링을 위해 **렌더 트리**(`render tree`)로 결합됨
- 렌더 트리는 렌더링을 위한 자료 구조로 브라우저 화면에 표시 되지 않는 노드(meta 태그 혹은 display : none 등..)는 포함되지 않는다.
- 완성된 렌더 트리는  각 HTML요소의 레이아웃을 계산하는 데 사용되며 브라우저 화면에 픽셀을 렌더링하는 페인팅 처리에 입력된다. 
- 정리 :  렌더트리 생성 -> 레이 아웃 계산 -> 페인팅 과정
- 위 렌더링 과정은 다음과 같은 경우 반복적으로 실행 될 수 있다.
	1. 자바스크립트에 의한 노드 추가 또는 삭제
	2. 브라우저 창의 리사이징에 의한 뷰포트 크기 변경
	3. HTML 요소의 레이아웃 변경(`width`, `margin`, `padding`, `display`, `position` 등의 스타일 변경)

> 리렌더링은 성능에 악영향을 주는 작업이므로 주의할 필요가 있다.

## 자바스크립트 파싱과 실행

- `DOM`은 `HTML` 문서의 구조와 정보 뿐만 아니라 `HTML`요소와 스타일 등을 변경할 수 있는 **DOM API**를 제공
- CSS 파싱과정과 동일하게 DOM 생성과정에서 자바스크립트 파일을 로드하는 `script`태그를 만나면 DOM 생성을 중지
- `script` 태그에 요청된 자바스크맂트 코드를 파싱하기위해 제어권을 자바스크립트 엔진으로 넘김, 이후 자바스크립트 파싱과 실행이 종료되면 렌더링 엔진으로 다시 제어권을 넘김
- 자바스크립트 엔진은 `DOM`이나 `CSSSOM`을 생성하듯이 자바스크립트를 해석하여 추상 구문 트리(**AST**, `Abstract Syntax Tree`)를 생성
- AST를 기반으로 인터프리터가 바이트코드를 생성

### 토크나이징(tokenizing)
- 단순 문자열인 자바스크립트 소스코드를 어휘 분석(`lexical analysis`)하여 문법적 의미를 갖는 코드의 최소 단위인 토큰들로 분해, 이 과정을 렉싱(`lexing`)이라고함

### 파싱(parsing)
- 토큰들의 집합을 구분 분석하여 `AST`를 생성 (`AST`는 토큰에 문법적 의미와 구조를 반영한 트리 구조)
- `AST`를 사용하여 인터프리터나 컴파일러를 구현
- `TypeScript`, `Babel`, `Prettier` 같은 트랜스 파일러 또한 구현 가능


### 바이트 코드 생성과 실행
-   파싱의 결과물로서 생성된  `AST`는 인터프리터가 실행할 수 있는 중간 코드인 바이트코드로 변환되고 인터프리터에 의해 실행.
-   `V8`  엔진의 경우 자주 사용되는 코드는 터보팬(`TurboFan`)이라 불리는 컴파일러에 의해 최적화된 머신 코드(`optimized machine code`)로 컴파일되어 성능을 최적화.
-   코드의 사용 빈도가 적어지면 다시 디옵티마이징(`deoptimizing`)하기도 함.

## 리플로우와 리페인트
- `DOM API`를 사용하여 `DOM`이나 `CSSOM`을 변경할 수 있음
- 변경된 `DOM`과 `CSSOM`은 다시 렌더트리로 결합 되고 레이아웃 계산, 페인트과정을 거쳐 브라우저의 화면에 다시 렌더링 한다, 이를 리플로우(`reflow`), 리페인트(`repaint`)라고 한다.
- 리플로우 : 레이아웃 계산을 다시하는 것(노드 추가/삭제, 요소 크기/위치 변경, 윈도우 리사이징 등등..)
- 리페인팅 : 변경된 사항을 렌더트리와 결합하여 다시 페인팅하는 과정을 말함
> 레이아웃에 변경이 없는 경우 레페인팅만 일어남

## 자바스크립트 파싱에 의한 HTML 파싱 중단
- 렌더링 엔진과 자바스크립트 엔진은 병렬적으로 파싱을 실행하지 않고 **직렬적으로 파싱을 수행**합니다.
- 브라우저는 동기적(synchronous)으로, 위에서 아래 방향으로 순차적으로 파싱하고 실행합니다
> 따라서 script 태그의 위치는 중요한 의미를 갖는다.
- 예를 들어 `header`에서 DOM을 조작하는 경우 실행 시점에 HTML 요소가 전부 파싱되어 렌더 트리가 형성되어 있지 않기 때문에 에러가 날 수 있다.
- `<script>`태그를 body 요소의 가장 아래에 위치 시키는 것도 방법
> 이렇게 하면 DOM이 완성된 상태에서 자바스크립트가 실행 되어 에러가 나지 않음
> 자바스크립트 로딩/파싱/실행 으로 인해 HTML요소들의 렌더링에 지장받는 일이 발생하지 않아 페이지 로딩 시간 단축

## script 태그의 async / defer 어트리뷰트
- 자바스크립트 파싱에 의한 DOM 생성 중단 (`blocking`)문제를 해결하기 위해 HTML5부터 script 태그에 async 와 defer 어트리뷰트가 추가되었다. 
- async /defer 어티리뷰트는 src 통해 외부 자바스크리트 파일을 로드하는 경우에만 사용할 수 있다. 
- HTML 파싱과 자바스크립트 파일의 로드를 비동기적으로 진행하기 위해 사용한다.
- async / defer 차이점은 자바스크립트의 실행 시점

### async 어트리뷰트
- HTML 파싱과 자바스크립트 파일 로드가 비동기적으로 진행
- 단, 자바스크립트 파싱과 실행은 **자바스크립트 파일의 로드가 완료된 직후 진행**되며, 이때 HTML 파싱 중단
- script 태그의 순서와 상관없이 로드가 완료된 자바스크립트 부터 실행되므로 순서가 보장되지 않는다.

### defer 어트리뷰트
- async 와 마찬가지로 자바스크립트 파일의 로드가 비동기적으로 진행
- 단, 자바스크립트 파싱과 실행은 **HTML 파싱이 완료된 직후, 즉 DOM 생성이 완료된 직후** 진행
> DOM 생성이 완료된 직후에 DOMContentLoaaded 이벤트가 발생합니다.


