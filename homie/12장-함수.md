# 함수
### 수학에서의 함수
- 입력(`input`)을 받아 출력(`output`)을 내보내는 일련의 과정을 정의
### 프로그래밍 언어의 함수
- 일련의 과정을 문(`statement`)으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것
- **함수의 정의**를 통해 생성 **함수호출**을 통해 실행

### 함수 사용 이유
1. 코드의 재사용을 통한 중복 최소화
2. 유지 보수의 편의성
3. 코드 신뢰성 
4. 코드의 가독성

### 함수 리터럴
- 자바스크립트의 함수는 객체 타입의 값 입니다.
- 함수도 함수 리터럴로 생성 가능 즉, 함수는 객체
- 함수를 객체로 취급하는 것은 js의 특징
- 일반 객체는 호출할 수 없지만 함수는 호출 가능

### 함수 정의
- 변수는 *선언* 한다고 하지만  함수는 *정의* 한다고 표현함
- 함수 정의는 4가지 방법으로 가능
	- 함수 선언문
	- 함수 표현식
	- Function 생성자 함수
	- 화살표 함수(es6)
	
### 함수 선언문
- 함수 선언문은 표현식이 아닌 문
- 표현식이 아닌 문은 변수에 할당할 수 없다, 그런데 함수 선언문은 변수에 할당하는 게 가능
```js
var add = function add(x,y){
	return x + y;
}
// 함수 호출
console.log(add(2,5)); // 7
```
- js에서는 중의적인 코드가 존재하기 때문
	- `{}`은 블록문 일수도 있고 객체리터럴 일수도 있다.
	> 자바스크립트 엔진이 코드 문맥에 다라 해석을 다르게 함
	- 기명 함수 리터럴(함수이름)도 중의적인 코드
	> 함수 리터럴을 단독으로 사용 시 함수 선언문으로 해석, 변수할당 혹은 피연산자로 사용 시 함수 리터럴 표현식으로 해석
- 함수 선언 시 자바스크립트 엔진은 생성된 함수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고 거기에 함수 객체를 할당
- 함수는 함수이름으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자로 호출함

### 함수 표현식
- 자바스크립트의 함수는 일급 객체
> 일급 객체란 값의 성질을 갖는 객체를 말한다.
>  자바스크립트의 함수는 변수에할당, 프로퍼티의 값, 배열의 요소 등 값이 될 수 있으므로 일급객체 이다
- 함수 리터럴로 생성한 객체를 변수에 할당한 것을 **함수 표현식** 이라고 함
- 이때 함수 이름을 생략하면 **익명함수**

### 함수 생성 시점과 호이스팅
- 함수 선언문과 함수 표현식으로 정의한 함수는 각각 생성 시점이 다름
```js
// 함수 참조
console.dir(add); // ƒ add(x, y)
console.dir(sub); // undefined

// 함수 호출
console.log(add(2, 5)); // 7
console.log(sub(2, 5)); // TypeError: sub is not a function

// 함수 선언문
function add(x, y) {
  return x + y;
}

// 함수 표현식
var sub = function (x, y) {
  return x - y;
};
```
- **함수 선언문**은 변수 선언 처럼 런터임 이전에 **호이스팅** 된다.
- 단, 함수 선언문은 호이스팅시 변수 처럼 `undefined`로 초기화 되는 게 아니라 암묵적으로 함수 객체로 초기화 된다.
- **함수 표현식**은 변수에 함수 리터럴이 할당됨 즉 변수가 `undefined`로 호이스팅 되고 런타임에 함수 리터럴이 평가되어 **함수 객체** 가 된다.
- 정리 : 함수 표현식은 **변수 호이스팅** 발생, **함수 표현식 사용을 권장**

### 화살표 함수
- 기존 함수와 비교하여 표현과 내부 동작이 간략화 됨
- 생성자 함수로 사용할 수 없다.
- this 바인딩 방식이 기존 함수와 다름
- prototype 프로퍼티가 없음
- arguments 객체를 생성하지 않는다. 

## 함수 호출
- 함수 호출 시 인수와 매개 변수의 개수가 일치하는 지는 체크하지 않는다. 
- 인수가 할당되지 않은 매개변수는 `undefined`, 초과된 인수는 무시
- 함수는 한 가지 일만 해야 하며 가급적 작게 만들어야 한다.
-`return` 키워드 뒤에 반환값으로 사용 할 표현식을 명시적으로 지정하지 않으면 `undefined`가 반환된다.

## 참조에 의한 전달과 외부 상태의 변경
- 함수 내부에서 참조 값을 변경하면 원본 객체의 값이 바뀌는 `side effect`가 발생할 수 있음
- `side effect`대한 해결법
	- **옵저버 패턴** 사용
	- 객체를 불변객체(`immutable object`)로 만들어 사용
	> 깊은 복사를 통해 새로운 객체를 생성하고 재할당을 통해 교체하는 방법
- 외부상태를 변경하지 않고, 의존하지 않는 함수를 **순수 함수** 라고 한다. (함수형 프로그래밍)

## 다양한 함수 형태
### 즉시 실행함수
- 함수 정의와 동시에 즉시 호출 되는 함수를 즉시 실행 함수(`IIFE : Immediately Invoked Function Expression`) 라고 한다.
- 즉시 실행 함수는 단 한번만 호출되며 다시 호출할 수 없습니다.
```js
// 익명 즉시 실행 함수
(function () {
  var a = 3;
  var b = 5;
  return a * b;
}());

// 즉시 실행 함수도 일반 함수처럼 값을 반환할 수 있다.
var res = (function () {
  var a = 3;
  var b = 5;
  return a * b;
}());

console.log(res); // 15

// 즉시 실행 함수에도 일반 함수처럼 인수를 전달할 수 있다.
res = (function (a, b) {
  return a * b;
}(3, 5));

console.log(res); // 15
``` 
- 변수나 함수 이름의 충돌을 방지하기 위해 사용

### 중첩 함수
- 함수 내부에 정의된 함수를 **중첩 함수** 또는 **내부 함수**라고 한다.
- 중첩 함수는 외부 함수 내부에서만 호출 가능
- 외부 함수를 돕는 **헬퍼함수**의 역할을함
- 스코프, 클로저와 관련

### 콜백 함수
- 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 **콜백 함수**라고 합니다.
- 매개변수를 통해 함수의 외부에서 콜백 함수를 전달받음 함수를 **고차 함수**(`HOF : Higher-Order Function`)이라고 한다.
- 고차 함수는 콜백 함수를 자신의 일부분으로 합성
- 고차 함수는 전달 받을 콜백 함수의 **호출 시점을 결정**
- 콜백 함수는 고차 함수에 의해 호출 되며, 고차 함수는 필요에 따록 콜백 함수에 인수를 전달할 수 있다.

### 순수 함수
- 함수형 프로그래밍에서 어떤 외부 상태에 의존하지 않고, 변경도 하지 않는 즉, 부수효과(`side effect`)가 없는 함수를 **순수 함수** 라고 한다.
- 하나 이상의 인자를 전달받으며, 언제나 동일한 값을 반환한다.
- 인수를 변경하지 않는 것이 기본
```js
var count = 0; // 현재 카운트를 나타내는 상태

// 순수 함수 increase는 동일한 인수가 전달되면 언제나 동일한 값을 반환한다.
function increase(n) {
  return ++n;
}

// 순수 함수가 반환한 결과값을 변수에 재할당해서 상태를 변경
count = increase(count);
console.log(count); // 1

count = increase(count);
console.log(count); // 2
```


