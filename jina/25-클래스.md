# 25 클래스
## 1 클래스는 프로토타입의 문법적 설탕이 아닌 새로운 객체 생성 매커니즘
* 클래스는 생성자 함수와 유사하게 동작
* 클래스의 특징 (생성자 함수와 구별되는)
	* new 연산자와 함께 호출 
	* 상속을 지원하는 extends, super 키워드 제공
	* 호이스팅이 발생하지 않는 것처럼 동작
	* strick mode가 시행
	* [[Enumerable]] 값이 false
* 상속 관계 구현을 간결하고 명료하게 함
* 새로운 객체 생성 매커니즘

## 2 클래스 정의
* class 키워드 사용해 정의
* 클래스는 일급 객체

## 3 클래스 호이스팅
* 클래스는 함수로 평가됨 

## 4 인스턴스 생성
* New 연산자로 호출

## 5 메서드
* 클래스에서 정의할 수 있는 메서드
	* constructor
	* 프로토타입 메서드
	* 정적 메서드

### constructor
* 인스턴스를 생성하고 초기화하기 위한 메서드
* 클래스는 생성자 함수
```javascript
const me = new Person(‘Lee’);
console.dir(me);
/**
prototype.constructor = class Person
*/
```
* 인스턴스 프로퍼티가 됨
```javascript
const Person{
	constructor(name){
		// 생성한 객체의 프로퍼티가 됨
		this.name = name;
	}
}
```

> 클래스 constructor != 프로토타입 constructor  
> 프로토타입 constructor:  
> - 모든 프로토타입이 가지고 있는 프로퍼티  
> - 생성자 함수를 가리킴  

- - - -

constructor 특징
* 클래스 내에 한 개만 존재 가능
* 생략 가능
	* 생략 시 빈 객체 생성
* 초기화된 인스턴스 생성 시 constructor 내부에서 인스턴스 프로퍼티를 추가
* 내부에 return문 생략

### 프로토타입 메서드
* 생성자 함수를 사용해 인스턴스 생성 시, prototype.{methodName} 명시적으로 프로토타입에 메서드를 추가해야 함 
* 클래스는 몸체의 정의한 메서드가 프로토타입 메서드가 됨

### 정적 메서드
* 인스턴스를 생성하지 않아도 호출할 수 있는 메서드
* 클래스에 바인딩된 메서드가 됨
* 인스턴스로 호출할 수 없음

### 정적 메서드 vs 프로토타입 메서드
1. 프로토타입 체인, 정적 메서드: 클래스, 프로토타입 메서드: 인스턴스
2. 정적 메서드: 클래스로 호출, 프로토타입 메서드: 인스턴스로 호출
3. 정적 메서드: 인스턴스 프로퍼티 참조 불가, 프로토타입 메서드: 인스턴스 프로퍼티 참조 가능

### 클래스에서 정의한 메서드의 특징
1. function 키워드 생략, 메서드 축약 표현 사용
2. 메서드 정의시 콤마 필요 X
3. 암묵적으로 stric mode
4. 열거불가
5. non-constructor

## 6 클래스의 인스턴스 생성 과정
클래스 호출시 [[Construct]] 호출됨
1. 인스턴스 생성과 this 바인딩
2. 인스턴스 초기화
3. 인스턴스 반환

## 7 프로퍼티
### 인스턴스 프로퍼티
* constructor 내부에서 정의
* 인스턴스 프로퍼티는 언제나 public (private 프로퍼티는 현재 제안 중)

### 접근자 프로퍼티
* 접근자 함수 get, set

### 클래스 필드 정의 제안
* 클래스 몸체에서 필드 정의시 this에 클래스 바인딩해서는 안 됨
* this는 constructor와 메서드 내에서만 유효
* 인스턴스 생성시 클래스 필드를 초기화할 필요가 없다면 클래스 몸에서 필드를 정의할 필요가 없음
* 클래스 필드에 함수 할당 권장하지 않음 -> 프로토타입 메서드가 아닌 인스턴스 프로퍼티가 됨

### private 필드 정의 제안
* 인스턴스 프로퍼티, 클래스 필드는 언제나 public
* private 선두에  ‘#’ 
* 접근자 프로퍼티를 통해 간접적으로 접근 
* private필드는 클래스 몸체에 정의해야 함

### static 필드 정의 제안
* static 키워드 사용

## 8 상속에 의한 클래스 확장
* 기존 클래스를 상속받아 새로운 클래스를 확장
* 생성자 함수와 달리 확장할 수 있는 문법을 제공

### extends 키워드
* extends 키워드를 사용해 상속
* 프로토타입을 통해 상속 구현

### 동적 상속
* 생성자 함수를 상속받아 클래스 확장
```javascript
function Base(a){
	this.a = a;
}

class Derived extends Base{}
```

### 서브클래스의 constructor
* super은 수퍼클래스의 constructor를 호출해 인스턴스를 생성

### super 키워드
* super 동작
	1. super 호출 시 수퍼클래스의 constructor 호출
	2. super 참조하면 수퍼클래스의 메서드 호출

1. Super 호출
* Super 호출시 수퍼클래스의 constructor 호출
* 인스턴스 초기화를 위해 전달한 인수는 수퍼클래스와 서브클래스에 배분되고 상속 관계의 두 클래스는 서로 협력해 인스턴스를 생성

2. super 참조
* 메서드 내에서 super참조시 수퍼클래스의 메서드 호출


### 상속 클래스의 인스턴스 생성 과정
1. 서브클래스의 super 호출
	* 서브클래스는 수퍼클래스에게 인스턴스 생성을 위임 -> 서브클래스의 constructor에서 반드시 super을 호출해야 하는 이유
2. 수퍼클래스의 인스턴스 생성과 this 바인딩
	* this는 인스턴스 
	* new.target은 서브클래스가 생성한 것
4. 수퍼클래스의 인스턴스 초기화
5. 서브클래스 constructor로의 복귀와 this 바인딩
6. 서브클래스의 인스턴스 초기화
7. 인스턴스 반환